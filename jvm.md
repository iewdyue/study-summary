# 垃圾收集算法

## 标记-清除算法  mark-sweep
  最基础的回收算法，  
  标记分为2个阶段标记
  1. 标记未被引用的对象，若需要调用finalize()方法，则将该对象放入f-queue队列；
  2. f-queue队列对应的线程会对f-queue队列中的对象逐个调用finalize()方法，在该方法中，对象可以通过修改finalize()方法的内容，实现自救（比如将自己挂载到某个其它对象的引用上）    
   finalize方法 只会被调用一次，即对象自救的机会只有一次
  3. 针对2次标记后 未被引用的对象，则调用清除操作；  
 
  该算法的2个不足  
  a. 标记和清除的效率不够高；  
  b. 清除的空间存在碎片，是不连续的地址空间，不利于大对象的空间分配；  

## 清除-复制算法  mark-copy
  采用备份内存区，使用复制对象操作，解决碎片问题，存在一定的内存空间浪费，适用于对象存活率较低的内存整理场景，不适用于存活率较高的场景   
  缺点：  
  1. 复制效率不够高  
  2. 内存空间使用率低于100%，可能是90%甚至更低
  3. 
## 标记-整理算法 mark-compact
  标记过程与 标记-清除算法相同，后续执行整理操作，通过整理操作，将存货对象整理为一块连续的空间，解决碎片问题；  
  适用于老年代的内存管理，适用于对象存活率高的场景  

## 分代收集算法
  将内存空间按照对象的存货时长，划分为新生代、老年代、永久代，并根据各个区域的特性不同，采用不同的清理算法  
  新生代中，对象存活率低，故采用mark-copy算法，此算法执行代价低；  
  老年代中，对象存活率高，故采用mark-sweep或mark-compact算法。  
 


# 垃圾收集器
![image](https://user-images.githubusercontent.com/25241891/146507608-9f011eb1-0796-40b8-ab71-77ebdda93908.png)  
如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。  


## Serial收集器  -->  新生代
最基本的收集器，  使用复制算法整理新生代，单线程，单cpu， 简单、高效；  
stop the world
适用于运行在client模式下的虚拟机应用；  

## ParNew收集器  -->  新生代
Serial收集器的多线程版本，使用复制算法整理新生代，支持Serial收集器的所有控制参数  
该收集器适用于多核虚拟机环境；  

## Parallel Scavenge 收集器  --> 新生代
支持并行，使用复制算法
专注于达到可控制的吞吐率，是相对程序运行时间的。  
其它算法，如CMS算法，是专注于降低用户线程的停顿时间的，是绝对时间。  
例如：  原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了   










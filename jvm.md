# 垃圾收集算法

## 标记-清除算法  mark-sweep
  最基础的回收算法，  
  标记分为2个阶段标记
  1. 标记未被引用的对象，若需要调用finalize()方法，则将该对象放入f-queue队列；
  2. f-queue队列对应的线程会对f-queue队列中的对象逐个调用finalize()方法，在该方法中，对象可以通过修改finalize()方法的内容，实现自救（比如将自己挂载到某个其它对象的引用上）    
   finalize方法 只会被调用一次，即对象自救的机会只有一次
  3. 针对2次标记后 未被引用的对象，则调用清除操作；  
 
  该算法的2个不足  
  a. 标记和清除的效率不够高；  
  b. 清除的空间存在碎片，是不连续的地址空间，不利于大对象的空间分配；  

## 清除-复制算法  mark-copy
  采用备份内存区，使用复制对象操作，解决碎片问题，存在一定的内存空间浪费，适用于对象存活率较低的内存整理场景，不适用于存活率较高的场景   
  缺点：  
  1. 复制效率不够高  
  2. 内存空间使用率低于100%，可能是90%甚至更低
  3. 
## 标记-整理算法 mark-compact
  标记过程与 标记-清除算法相同，后续执行整理操作，通过整理操作，将存货对象整理为一块连续的空间，解决碎片问题；  
  适用于老年代的内存管理，适用于对象存活率高的场景  

## 分代收集算法
  将内存空间按照对象的存货时长，划分为新生代、老年代、永久代，并根据各个区域的特性不同，采用不同的清理算法  
  新生代中，对象存活率低，故采用mark-copy算法，此算法执行代价低；  
  老年代中，对象存活率高，故采用mark-sweep或mark-compact算法。  
 


# 垃圾收集器
![image](https://user-images.githubusercontent.com/25241891/146507608-9f011eb1-0796-40b8-ab71-77ebdda93908.png)
如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。  


## 
